<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>DragonQuest</title>
    <link rel="stylesheet" type="text/css" href="../Css/main.css">
</head>
<body class="Body">


<div class="titleContainer"><img class="dragonIcon" src="../Images/dragon.png">
    <div class="titleHead">
        <div class="title">Konsole B:</div>
        <img class="titleImg"
             src="../Images/title1.png"></div>
</div>

<div class="ImgContainer"><img class="headImg" src="../Images/header.png"></div>


<div class="NavigationBar">
    <ul class="NavigationList">
        <li><a class="NavigationPanel" href="../index.html">Start</a></li>
        <li><a class="NavigationPanel" href="../Team/index.html">Team</a></li>
        <li><a class="NavigationPanel" href="../Grundfunktionen/index.html">Grundfunktionen</a></li>
        <li><a class="NavigationPanel" href="../Spiellogik/index.html">Spiellogik</a>
        </li>
        <li><a class="NavigationPanel" href="../Code/index.html">Code</a></li>
    </ul>
</div>

<h1 class="formatHeader">Grundfunktionen</h1>

<h2 class="formatHeader">Zeichnen</h2>
<div class="textContainer">
    Grundlage um auf dem Display zu zeichnen ist die Funktion page( x, y, hex). Bei dieser Funktion werden immer vier vertikale Pixel zu einer Page zusammengefasst. Die Farbe eines Pixels wird mit zwei Bit definiert.  Da eine Page vier Pixel beschreibt und ein Pixel durch zwei Bits definiert wird ist der Wert einer Page 8 Bit lang. Das unterste Pixel einer Page wird durch die zwei höchstwertigen Bits repräsentiert.

    Da wir unsere Sprits nicht nur pageweise verschieben wollen, sondern auch pixelweise,  mussten wir uns hierzu eine neue Funktion schreiben, die automatisch das Bitshifften übernimmt. Desweiteren sollte in y-Richtung nicht die Page(0-25) angesteuert werden, sondern der jeweilige Pixel(0-104).
    <h3>drawCorrect(x,y, hex)</h3>
    Aus unser Überlegung entstand die Funktion drawCorrect() welche die gewünschte Page an jede beliebige Stelle auf dem Display zeichnet.
    In der Funktion wird über die y-Koordinate und der Modulofunktion geschaut welche Pages angesprochen werden, so werden 4 Fälle unterschieden.
    Durch das Bitshiften werden die Bits auf die jeweilige Page geschoben.
    Um zu verhindern, dass bei einem Sprit eine Page die voherige Page überschreibt, wird immer die letzte gezeichnete Page gespeichert. Falls auf diese geschrieben werden soll wird die neue Page und die alte Page verordert. Daher ergibt sich für unser Programm die Regel beim Zeichen von Sprits eine Spalte immer von oben nach unten malen zu lassen.
<div class="doubleImage">
<img class="formatImage" src="../Images/DrawCorrect1.png">
    <img class="formatImage" src="../Images/DrawCorrect2.png">
</div>
    <h3>Sprits Zeichene</h3>
    Um unsere Helden und Powerups zu zeichnen nutzen wir Gimp. Nachdem das gewünschte Sprit fertig ist exportiern wir dieses als pgm Datei(Portable Greaymap). Das Dateiformat bietet sich für uns sehr gut an, da es leicht weiter zu verarbeiten ist.
    Um die Sprits im Code nutzen zu können wird ein Pythonscript genutzt welche die Pixel in Pages gruppirt und die Farbwerte in Hexadezimalzahlen umwandelt.

</div>
<h2 class="formatHeader">Sound</h2>
<div class="textContainer">
    <p>
        Der Sound wurde mit Hilfe des PWM Moduls, des Microkontollers ATmega168, generiert. Im Grunde wird an den Lautsprecher ein Rechtecksignal angelegt. Die Tonhöhe wird mit der Frequenz gesteuert. Je schneller die Frequenz desto höher der Ton.
    </p>
    <p>
        Um die Erzeugung von Tonabfolgen zu erleichtern wurde im Vorfeld zu einige Tönen ihre Frequenz speichen. In Folge dessen brauchen man nur den gewünschten Ton zu schreiben und bekam automatisch die dazugehörige Frequenz.
    </p>
    <p>
        Bei der Recherche schtiesen wir auf eine sehr hilfreiche Webanwendung(www.beepbox.co), welches uns erlaubt Tonabfolgen zu testen und so möglicht schnell brauchbare Sounds zu generieren.
    </p>
    <h3>Wie werden Sounds gespeichert?</h3>
    <p>
        Um eine Tonabfoleg zu spielen wurde diese in einem Array gespeichert. Ein Tonwert bestand aus der Frequenz des Tones und der Dauer in Millisekunden.
    </p>
    <h3>Wie werden Sounds abgespielt?</h3>
    <p>
        Um Sounds abzuspielen wird das Soundarray durchlaufen und die jeweilige Frequenz an die PWM übergeben und für die gewünschte Dauer gewartet bis die nächste Frequenz übergeben wird.
    </p>
</div>

<h2 class="formatHeader">Animation</h2>

<div class="textContainer">
<p>
    Die Animation der Figuren ist sehr grundlegend. Es werden lediglich zwei Bilder alle sechs Frames abgewechselt.
    Die sechs Frames sind ein Erfahrungswert, bei dem die Animation am flüssigsten aussieht.
</p>
</div>

<h2 class="formatHeader">Entprellen</h2>
<img alt="Ups!" src="../Images/button.png" class="formatImage">

<div class="textContainer">
<p>
    Das Entprellen der Tasten wird mit einem Zustandsautomaten gelöst. Der Automat startet im "open"-Zustand. Sobald eine Taste betätigt wird, geht der Automat über in den "locked"-Zustand, wartet 150 ms und kehrt zurück in den "open"-Zustand.
    Beim Warten im "locked"-Zustand handelt es sich um aktives Warten. Mit 150 ms als Wartequantum werden ungewollte doppelte Tastendrücke verhindert aber trotzdem ein responsives Verhalten der
    Tasten ermöglicht.
</p>
</div>

<h2 class="formatHeader">Zufallswerte</h2>

<div class="textContainer">
<p>
    Um Zufallswerte zu erzeugen wird die rand()-Funktion der Standardbibliothek "stdlib.h" von C verwendet.
    Als Startwert für den Pseudozufallszahlengenerator wird das Rauschen eines nicht angeschlossenen Kanals des Analog-Digital-Wandlers des Mikrocontrollers verwendet.

</p>
</div>

</body>
</html>